use EMP_DEPT_DB;
go

SELECT * FROM employee;
SELECT * FROM department;
go

BEGIN
DECLARE @NAME VARCHAR(50),@SALARY INTEGER,@DEPT_ID VARCHAR(10)='D3';
SELECT @NAME=EMP_NAME,@SALARY=EMP_SALARY FROM employee
WHERE emp_deptId=@DEPT_ID;
SELECT @NAME AS'NAME',@SALARY AS'SALARY';
BEGIN 
PRINT'DEPARTMENT ID:'+@DEPT_ID;
END
END
GO

--BEGIN and END are used in Transact-SQL to group a set of statements into a single compound statement,
--so that control statements such as IF â€¦ ELSE,
--which affect the performance of only a single SQL statement, can affect the performance of the whole group.

--IF...ELSE --
BEGIN
DECLARE @SALARY DECIMAL;
SELECT @SALARY=AVG(EMP_SALARY)FROM employee;
SELECT @SALARY AS 'AVG.SALARY';

IF @SALARY> 85000
BEGIN 
PRINT 'AVG SALARY IS GREATER THAN 30000';
END
ELSE
BEGIN
PRINT 'AVG SALARY IS LESS THAN 30000';
END
END
GO

--WHILE LOOPS
--- CONTROL  FLOWS THATS ALLOWS YOU TO EXECUTE A STATMENT BLOCK REPEATDLY AS LONG AS SPECIFIED CONDITION IS TRUE.
--EXECUTION OF STATEMENTS IN THE WHILE LOOP CAN BE CONTROLLED FROM INSIDE THE LOOP WITH THE BREAK AND CONTINUE KEYWORDS.
SELECT * FROM EMP_DEPT_DB.DBO.employee;

BEGIN WHILE  (SELECT MIN(EMP_SALARY)FROM employee)<40000
BEGIN
UPDATE employee SET emp_salary =emp_salary+10000;
PRINT 'ALL SALARIES ARE UPDATED';
SELECT*FROM employee;
IF(SELECT MIN(EMP_SALARY)FROM employee)>=40000
PRINT'MIN.SALARY IS GREATER OR EQUAL TO 40000.';
BREAK;
END
END

--TRY ... CATCH
--IMPLEMNTS ERROR HANDLING FOR T-SQL.IT IS SIMILAR TO THE EXCEPTION HANDLING IN THE OOP'S LANG. SUCH AS C++,JAVA,JS,ETC.
--A GROUP OF T - SQL STATEMENTS CAN BE ENCLOSED IN A TRY BLOCK.
--IF THE SATEMENT B/W THE TRY BLOCK COMPLETE WITHOUT AN ERROR,THE STATEMENTS B/W THE CATCH WILL NOT EXECUTE. 
--HOWEVER,IF ANY STATEMENT INSIDE THE TRY BLOCK CAUESE AN EXCEPTION,THE CONTROL TRANSFERS TO THE STATEMENTS IN THE CATCH BLOCK.

BEGIN TRY
SELECT 100/5 AS' DIVISION';
END TRY
BEGIN CATCH
SELECT ERROR_MESSAGE() AS'ERROR MESSAGE',ERROR_LINE()AS 'ERROR LINE',
ERROR_NUMBER()AS 'ERROR NUMBER',ERROR_PROCEDURE()AS'PROCEDURE';
END CATCH

BEGIN TRY
SELECT 100/0 AS' DIVISION';
END TRY
BEGIN CATCH
SELECT ERROR_MESSAGE() AS'ERROR MESSAGE',ERROR_LINE()AS 'ERROR LINE',
ERROR_NUMBER()AS 'ERROR NUMBER',ERROR_PROCEDURE()AS'PROCEDURE';
END CATCH
SELECT ERROR_MESSAGE() AS'ERROR MESSAGE',ERROR_LINE()AS 'ERROR LINE',
ERROR_NUMBER()AS 'ERROR NUMBER',ERROR_PROCEDURE()AS'PROCEDURE';



BEGIN TRY
SELECT 100/5 AS' DIVISION';
END TRY
BEGIN CATCH

END CATCH


--WAITFOR
--BLOCKS THE EXCEUTIUON OF A BATCH ,STORED PROCEDURE ,OR TRANSACTION UNTIL 
--EITHER A SPECIFIED TIME OR TIME INTERVAL ELAPSES ,OR A SPECIFIED MODIFIES OR RETURNS AT LEAST ONE ROW.
--WAITFOR HAS TWO ARGUMENTS:
--1..TIME - THE PEROID OF TIME TO WAIT.TIME_TO_PASS
--2.DELAY - THE TIME (UP TO A MAXIMUM OF 24 hrs.)AT WHICH THE WAITFOR STATEMENT FINISHES
SELECT GETDATE();
GO 
BEGIN WAITFOR TIME'11:18:00'
SELECT *FROM EMP_DEPT_DB.DBO.employee;
END
GO
SELECT GETDATE()AS 'CURRENT TIME';
GO


SELECT GETDATE();
GO 
BEGIN WAITFOR DELAY'00:00:10'
SELECT *FROM EMP_DEPT_DB.DBO.employee;
END
GO
SELECT GETDATE()AS 'CURRENT TIME';
GO